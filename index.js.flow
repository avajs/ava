// @flow
export interface PromiseLike<R> {
	then<U>(onFulfill?: (value: R) => Promise<U> | U, onReject?: (error: any) => Promise<U> | U): Promise<U>;
}

export interface ObservableLike {
	subscribe(observer: (value: any) => void): void;
}

export type Constructor = Class<{constructor(...args: Array<any>): any}>;

/** Specify one or more expectations the thrown error must satisfy. */
export type ThrowsExpectation = {
	/** The thrown error must be an instance of this constructor. */
	instanceOf?: Constructor;

	/** The thrown error must be strictly equal to this value. */
	is?: Error;

	/** The thrown error must have an error that equals the given string, or matches the regular expression. */
	message?: string | RegExp;

	/** The thrown error must have a name that equals the given string. */
	name?: string;
};

export type ThrowsErrorValidator = Constructor | RegExp | string | ThrowsExpectation;

/** Options that can be passed to the `t.snapshot()` assertion. */
export interface SnapshotOptions {
	/** If provided and not an empty string, used to select the snapshot to compare the `expected` value against. */
	id?: string;
}

export interface Assertions {
	/** Assert that `actual` is [deeply equal](https://github.com/concordancejs/concordance#comparison-details) to `expected`. */
	deepEqual(actual: any, expected: any, message?: string): void;

	/** Fail the test. */
	fail(message?: string): void;

	/** Assert that `actual` is strictly false. */
	false(actual: any, message?: string): void;

	/** Assert that `actual` is [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy). */
	falsy(actual: any, message?: string): void;

	/**
	 * Assert that `actual` is [the same
	 * value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) as `expected`.
	 */
	is(actual: any, expected: any, message?: string): void;

	/**
	 * Assert that `actual` is not [the same
	 * value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) as `expected`.
	 */
	not(actual: any, expected: any, message?: string): void;

	/** Assert that `actual` is not [deeply equal](https://github.com/concordancejs/concordance#comparison-details) to `expected`. */
	notDeepEqual(actual: any, expected: any, message?: string): void;

	/** Assert that `string` does not match the regular expression. */
	notRegex(string: string, regex: RegExp, message?: string): void;

	/** Assert that the function returns an observable that does not error. You must await the result. */
	notThrows(value: () => ObservableLike, message?: string): Promise<void>;

	/** Assert that the function returns a promise that does not reject. You must await the result. */
	notThrows(value: () => PromiseLike<any>, message?: string): Promise<void>;

	/** Assert that the function does not throw. */
	notThrows(value: () => any, message?: string): void;

	/** Assert that the observable does not error. You must await the result. */
	notThrows(value: ObservableLike, message?: string): Promise<void>;

	/** Assert that the promise does not reject. You must await the result. */
	notThrows(value: PromiseLike<any>, message?: string): Promise<void>;

	/** Count a passing assertion. */
	pass(message?: string): void;

	/** Assert that `string` matches the regular expression. */
	regex(string: string, regex: RegExp, message?: string): void;

	/**
	 * Assert that `expected` is [deeply equal](https://github.com/concordancejs/concordance#comparison-details) to a
	 * previously recorded [snapshot](https://github.com/concordancejs/concordance#serialization-details), or if
	 * necessary record a new snapshot.
	 */
	snapshot(expected: any, message?: string): void;

	/**
	 * Assert that `expected` is [deeply equal](https://github.com/concordancejs/concordance#comparison-details) to a
	 * previously recorded [snapshot](https://github.com/concordancejs/concordance#serialization-details) (selected
	 * through `options.id` if provided), or if necessary record a new snapshot.
	 */
	snapshot(expected: any, options: SnapshotOptions, message?: string): void;

	/**
	 * Assert that the function returns an observable that errors with [an error](https://www.npmjs.com/package/is-error).
	 * If so, returns the error value. You must await the result.
	 */
	throws(value: () => ObservableLike, error?: ThrowsErrorValidator, message?: string): Promise<any>;

	/**
	 * Assert that the function returns a promise that rejects with [an error](https://www.npmjs.com/package/is-error).
	 * If so, returns the rejection reason. You must await the result.
	 */
	throws(value: () => PromiseLike<any>, error?: ThrowsErrorValidator, message?: string): Promise<any>;

	/**
	 * Assert that the function throws [an error](https://www.npmjs.com/package/is-error). If so, returns the error value.
	 * The error must be an instance of the given constructor.
	 */
	throws(value: () => any, error?: ThrowsErrorValidator, message?: string): any;

	/**
	 * Assert that the observable errors with [an error](https://www.npmjs.com/package/is-error). If so, returns the error
	 * value. You must await the result. The error must be an instance of the given constructor.
	 */
	throws(value: ObservableLike, error?: ThrowsErrorValidator, message?: string): Promise<any>;

	/**
	 * Assert that the promise rejects with [an error](https://www.npmjs.com/package/is-error). If so, returns the
	 * rejection reason. You must await the result. The error must be an instance of the given constructor.
	 */
	throws(value: PromiseLike<any>, error?: ThrowsErrorValidator, message?: string): Promise<any>;

	/** Assert that `actual` is strictly true. */
	true(actual: any, message?: string): void;

	/** Assert that `actual` is [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy). */
	truthy(actual: any, message?: string): void;
}

/** The `t` value passed to test & hook implementations. */
export interface ExecutionContext<Context = {}> extends Assertions {
	/** Test context, shared with hooks. */
	context: Context;

	skip: Assertions;

	/** Title of the test or hook. */
	title: string;

	log(...values: Array<any>): void;

	plan(count: number): void;
}

/** The `t` value passed to implementations for tests & hooks declared with the `.cb` modifier. */
export interface CbExecutionContext<Context = {}> extends ExecutionContext<Context> {
	/**
	 * End the test. If `error` is [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy) the test or hook
	 * will fail.
	 */
	end(): void;
}

export type ImplementationResult = PromiseLike<void> | ObservableLike | Iterator<any> | void;
export type Implementation<Context = {}> = {(t: ExecutionContext<Context>): ImplementationResult};
export type CbImplementation<Context = {}> = {(t: CbExecutionContext<Context>): ImplementationResult};

export interface Macro<Context = {}> {
	(t: ExecutionContext<Context>, ...args: Array<any>): ImplementationResult;
	title?: (providedTitle: string, ...args: Array<any>) => string;
}

export interface CbMacro<Context = {}> {
	(t: CbExecutionContext<Context>, ...args: Array<any>): ImplementationResult;
	title?: (providedTitle: string, ...args: Array<any>) => string;
}

export interface TestInterface<Context = {}> {
	(title: string, implementation: Implementation<Context> | Macro<Context>): void;
	(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;
	(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;

	/** Specify a hook that run once all test have completed */
	after: AfterInterface<Context>;

	/** Specify a hook that run after each test */
	afterEach: AfterInterface<Context>;

	/** Specify a hook that run before all test runs */
	before: BeforeInterface<Context>;

	/** Specify a hook that run before each test */
	beforeEach: BeforeInterface<Context>;

	/** Specify a hook/test that support callbacks */
	cb: CbInterface<Context>;

	/** Specify a test that fails */
	failing: FailingInterface<Context>;

	/** Specify a test that run only this test */
	only: OnlyInterface<Context>;

	/** Specify a test/hook that run serially */
	serial: SerialInterface<Context>;

	/** Specify a test/hook that will be skipped */
	skip: SkipInterface<Context>;

	/** TODO tests/hooks */
	todo: TodoDeclaration;
}

export interface AfterInterface<Context = {}> {
	(title: string, implementation: Implementation<Context> | Macro<Context>): void;
	(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;
	(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;

	always: AlwaysInterface<Context>;
	cb: HookCbInterface<Context>;
	skip: SkipInterface<Context>;
}

export interface AlwaysInterface<Context = {}> {
	(title: string, implementation: Implementation<Context> | Macro<Context>): void;
	(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;
	(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;

	cb: HookCbInterface<Context>;
	skip: SkipInterface<Context>;
}

export interface BeforeInterface<Context = {}> {
	(title: string, implementation: Implementation<Context> | Macro<Context>): void;
	(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;
	(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;

	cb: HookCbInterface<Context>;
	skip: SkipInterface<Context>;
}

export interface CbInterface<Context = {}> {
	(title: string, implementation: CbImplementation<Context> | CbMacro<Context>): void;
	(title: string, macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;
	(macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;

	failing: CbFailingInterface<Context>;
	only: CbOnlyInterface<Context>;
	skip: CbSkipInterface<Context>;
}

export interface CbFailingInterface<Context = {}> {
	(title: string, implementation: CbImplementation<Context> | CbMacro<Context>): void;
	(title: string, macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;
	(macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;

	only: CbOnlyInterface<Context>;
	skip: CbSkipInterface<Context>;
}

export interface CbOnlyInterface<Context = {}> {
	(title: string, implementation: CbImplementation<Context> | CbMacro<Context>): void;
	(title: string, macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;
	(macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;
}

export interface CbSkipInterface<Context = {}> {
	(title: string, implementation: CbImplementation<Context> | CbMacro<Context>): void;
	(title: string, macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;
	(macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;
}

export interface FailingInterface<Context = {}> {
	(title: string, implementation: Implementation<Context> | Macro<Context>): void;
	(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;
	(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;

	only: OnlyInterface<Context>;
	skip: SkipInterface<Context>;
}

export interface HookCbInterface<Context = {}> {
	(title: string, implementation: CbImplementation<Context> | CbMacro<Context>): void;
	(title: string, macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;
	(macro: CbMacro<Context> | CbMacro<Context>[], ...args: Array<any>): void;

	skip: CbSkipInterface<Context>;
}

export interface OnlyInterface<Context = {}> {
	(title: string, implementation: Implementation<Context> | Macro<Context>): void;
	(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;
	(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;
}

export interface SerialInterface<Context = {}> {
	(title: string, implementation: Implementation<Context> | Macro<Context>): void;
	(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;
	(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;

	after: AfterInterface<Context>;
	afterEach: AfterInterface<Context>;
	before: BeforeInterface<Context>;
	beforeEach: BeforeInterface<Context>;
	cb: CbInterface<Context>;
	failing: FailingInterface<Context>;
	only: OnlyInterface<Context>;
	skip: SkipInterface<Context>;
	todo: TodoDeclaration;
}

export interface SkipInterface<Context = {}> {
	(title: string, implementation: Implementation<Context> | Macro<Context>): void;
	(title: string, macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;
	(macro: Macro<Context> | Macro<Context>[], ...args: Array<any>): void;
}

export type TodoDeclaration = {(title: string): void};

declare export default TestInterface<>;

declare export var test: TestInterface<>;
declare export var after: AfterInterface<>;
declare export var afterEach: AfterInterface<>;
declare export var before: BeforeInterface<>;
declare export var beforeEach: BeforeInterface<>;
declare export var cb: CbInterface<>;
declare export var failing: FailingInterface<>;
declare export var only: OnlyInterface<>;
declare export var serial: SerialInterface<>;
declare export var skip: SkipInterface<>;
declare export var todo: TodoDeclaration;
